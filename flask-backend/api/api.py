import os
import base64
import csv
from rosbags.rosbag2 import Reader
from rosbags.typesys import Stores, get_typestore
import cv2
import numpy as np
from flask import Flask, jsonify, request
from flask_cors import CORS
import logging
import pandas as pd

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Define the rosbag file path
rosbag_path = '/home/ubuntu/Documents/Bachelor/testcode/rosbag2_2024_08_01-16_00_23'

# Create a typestore and get the Image message class
typestore = get_typestore(Stores.LATEST)

# Store the available timestamps globally
#timestamps = [str(timestamp) for timestamp in[1722520823794554837, 1722520823882716860, 1722520823956266496, 1722520824044949775, 1722520824129536481, 1722520824212327873, 1722520824306384942, 1722520824381265647, 1722520824461008367, 1722520824539358681, 1722520824621277170, 1722520824713218139, 1722520824789318353, 1722520824866560576, 1722520824954846158, 1722520825030787463, 1722520825109856709, 1722520825189139193, 1722520825260627709, 1722520825334578912, 1722520825415140665, 1722520825493658925, 1722520825567736007, 1722520825651309732, 1722520825729545476, 1722520825810603094, 1722520825882163969, 1722520825965439157, 1722520826048326518, 1722520826129086849, 1722520826208738069, 1722520826291113885, 1722520826376063257, 1722520826456159383, 1722520826529308364, 1722520826609944575, 1722520826681221533, 1722520826754791219, 1722520826837016316, 1722520826910092357, 1722520826986138231, 1722520827067852642, 1722520827154912075, 1722520827229905738, 1722520827310484930, 1722520827387957641, 1722520827460805874, 1722520827538805820, 1722520827615537016, 1722520827695033028, 1722520827782205050, 1722520827849540534, 1722520827923015430, 1722520828004230866, 1722520828080472058, 1722520828165707387, 1722520828244380517, 1722520828307172621, 1722520828377364258, 1722520828465206664, 1722520828526804989, 1722520828613324917, 1722520828684100098, 1722520828756040760, 1722520828828457146, 1722520828904629089, 1722520828976913496, 1722520829058203252, 1722520829136538274, 1722520829219816220, 1722520829287868417, 1722520829360638780, 1722520829435889340, 1722520829507764462, 1722520829580916102, 1722520829663945321, 1722520829740694218, 1722520829827841089, 1722520829906147261, 1722520829980822537, 1722520830054376763, 1722520830129607794, 1722520830204515967, 1722520830282207475, 1722520830355415554, 1722520830433594457, 1722520830510824350, 1722520830589164622, 1722520830673004533, 1722520830764555014, 1722520830834442933, 1722520830912939174, 1722520830998540340, 1722520831074061508, 1722520831160499414, 1722520831243587603, 1722520831328211257, 1722520831415300939, 1722520831482736491, 1722520831556054729, 1722520831634255062, 1722520831776525338, 1722520831857916831, 1722520831938739970, 1722520832004671886, 1722520832086179489, 1722520832153158194, 1722520832243696374, 1722520832320480660, 1722520832399215818, 1722520832470387295, 1722520832546872444, 1722520832619465279, 1722520832693452340, 1722520832774141630, 1722520832846329079, 1722520832921984154, 1722520833000117388, 1722520833088932133, 1722520833171930863, 1722520833237628100, 1722520833317067001, 1722520833394697739, 1722520833470940370, 1722520833546521286, 1722520833622663878, 1722520833698407213, 1722520833772218787, 1722520833859650075, 1722520833942580974, 1722520834016015200, 1722520834098947180, 1722520834190603748, 1722520834261406559, 1722520834337641910, 1722520834427018420, 1722520834494611179, 1722520834583248466, 1722520834665730450, 1722520834726627091, 1722520834805113321, 1722520834881712348, 1722520834975033302, 1722520835041361244, 1722520835118444946, 1722520835194071372, 1722520835266775735, 1722520835343068245, 1722520835424936724, 1722520835502958328, 1722520835578541324, 1722520835648749660, 1722520835721356524, 1722520835798586145, 1722520835883838953, 1722520835967637294, 1722520836037498313, 1722520836119871957, 1722520836193681249, 1722520836264065493, 1722520836334511677, 1722520836413327403, 1722520836487975318, 1722520836558564210, 1722520836636472145, 1722520836719535733, 1722520836815723700, 1722520836882376568, 1722520836968864914, 1722520837046847108, 1722520837120814929, 1722520837196452195, 1722520837271755714, 1722520837349239232, 1722520837429250118, 1722520837506435159, 1722520837588382496, 1722520837670653241, 1722520837754941457, 1722520837841131166, 1722520837925800239, 1722520838007363000, 1722520838088256397, 1722520838163464566, 1722520838239875295, 1722520838311453468, 1722520838396103301, 1722520838475396792, 1722520838541875432, 1722520838613905880, 1722520838696898828, 1722520838770243524, 1722520838853012195]]
timestamps = []

# Load the CSV into a pandas DataFrame (global so it can be accessed by the API)
aligned_data = pd.read_csv('/home/ubuntu/Documents/Bachelor/bagseek/aligned_data_with_max_distance.csv', dtype=str)

# Endpoint to get available topics from the CSV file
@app.route('/api/topics', methods=['GET'])
def get_rosbag_topics():
    with Reader(rosbag_path) as reader:
        # Extract all topics using a set to avoid duplicates
        topics = list({conn.topic for conn in reader.connections})

    return jsonify({'topics': topics}), 200

@app.route('/api/timestamps', methods=['GET'])
def get_timestamps():
    # Extract the first column (Reference Timestamp) from the PD Frame
    timestamps = aligned_data['Reference Timestamp'].astype(str).tolist()

    return jsonify({'timestamps': timestamps})

@app.route('/api/ros', methods=['GET'])
def get_ros_image():
    timestamp = request.args.get('timestamp', default=None, type=str)  # Get timestamp from query params
    topic = request.args.get('topic', default=None, type=str)  # Get topic from query params

    if timestamp is None:
        return jsonify({'error': 'No timestamp provided'})
    if topic is None:
        return jsonify({'error': 'No topic provided'})

    row = aligned_data[aligned_data['Reference Timestamp'] == timestamp]
    realTimestamp = row[topic].iloc[0]

    ### kann sein dass das nicht funktioniert
    # Check if timestamp exists in aligned_data
    if timestamp not in aligned_data['Reference Timestamp'].values:
        return jsonify({'error': 'Timestamp not found in aligned_data'})

    # Check if the topic exists as a column in aligned_data
    if topic not in aligned_data.columns:
        return jsonify({'error': f'Topic {topic} not found in aligned_data'})

    
    # Open the rosbag to find the image at the requested timestamp and topic
    with Reader(rosbag_path) as reader:
        connections = [x for x in reader.connections if x.topic == topic]

        for connection, msg_timestamp, rawdata in reader.messages(connections=connections):
            if str(msg_timestamp) == realTimestamp:
                # Deserialize the message based on the connection's message type
                msg = typestore.deserialize_cdr(rawdata, connection.msgtype)

                # Check if the message is an image (sensor_msgs/msg/Image)
                if connection.topic == topic and hasattr(msg, 'encoding'):
                    if msg.encoding == 'rgb8':
                        image_data = np.frombuffer(msg.data, dtype=np.uint8).reshape((msg.height, msg.width, 3))
                        image_data = cv2.cvtColor(image_data, cv2.COLOR_RGB2BGR)
                    elif msg.encoding == 'bgr8':
                        image_data = np.frombuffer(msg.data, dtype=np.uint8).reshape((msg.height, msg.width, 3))
                    else:
                        print(f"Unsupported encoding {msg.encoding}")
                        continue

                    # Convert the image to a byte stream
                    _, img_bytes = cv2.imencode('.png', image_data)
                    img_base64 = base64.b64encode(img_bytes.tobytes()).decode('utf-8')
                    return jsonify({'image': img_base64, 'realTimestamp': realTimestamp})  # Return the image and value
    return jsonify({'error': 'No image found for the provided timestamp'})



if __name__ == '__main__':
    app.run(debug=True)
    
